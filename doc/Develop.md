## Создание нового компонента

Ниже описаны шаги, по которым необходимо пройти при написании нового компонента.

### Сообщения

Прежде всего необходимо реализовать сообщения, которыми будет оперировать компонент.

> NB: все сообщения, которые относятся к какому-нибудь одному проекту, описываются в одной библиотеке.
> Например, все сообщения семантической системы (ss) описываются в библиотеке [ss-mq-types](https://github.com/biocad/ss-mq-types).

Возможно, что используемые сообщения уже реализованы, тогда можно переходить к следующему пункту.

Примеры для реализаций можно найти в следующих файлах: [ExampleCalculatorTypes.hs](../app/ExampleCalculatorTypes.hs), [ExampleClockTypes.hs](../app/ExampleClockTypes.hs), [ExampleBankTypes.hs](../app/ExampleBankTypes.hs), [ExampleRadioTypes.hs](../app/ExampleRadioTypes.hs).

Для каждого сообщения, помимо его определения, необходимо объявить возможность кодировки в JSON или MessagePack.
После этого его необходимо сделать представителем класса `MessageLike`, в котором определяются параметры сообщения (`spec`, `encoding`, `type`), которые используются для автоматического преобразования.

### Логика компонента

После того, как объявлены сообщения, можно перейти к реализации логики компонента.

У компонента есть два уровня: технический и коммуникационный.
При разработке очередного компонента нужно реализовать логику только коммуникационного уровня.
Простейший пример можно посмотреть в компоненте `RadioSpeaker`, где функция [`radioSpeaker`](https://github.com/biocad/mq-component-hs/blob/9e60091571ec089a830e7cf3c89de219c480cf3e/app/ExampleRadioSpeaker.hs#L21) описывает всю логику этого компонента.

Можно увидеть, что на этой [строчке](https://github.com/biocad/mq-component-hs/blob/9e60091571ec089a830e7cf3c89de219c480cf3e/app/ExampleRadioSpeaker.hs#L22) разработчик получает доступ к двум каналам.
В один канал он может [отправлять сообщения](https://github.com/biocad/mq-component-hs/blob/9e60091571ec089a830e7cf3c89de219c480cf3e/app/ExampleRadioSpeaker.hs#L27), а из другого - получать.
В том случае, если компонент получает задачу через контроллер, то можно вызвать аналогичную функцию `load3Channels`, описанную в [этом](../src/System/MQ/Component/Internal/Config.hs) файле.

Этого достаточно для того, чтобы реализовать практически любую логику.

### Шаблоны

Очень часто при реализации компонентов встречаются схожие шаблоны поведения, которые хочется описать один раз, а потом их переиспользовать.
В данной библиотеке такие шаблоны описаны в директории [Extras](../src/System/MQ/Component/Extras/Template).

На примере [RadioListener](../app/ExampleRadioListener.hs) можно посмотреть на шаблон `listener`, который отвечает за получение определённых сообщений с последующей обработкой.

На примере [Calculator](../app/ExampleCalculator.hs) можно посмотреть на шаблон "рабочий", который получает сообщения с конфигурацией напрямую от Scheduler.

А на примере [ClockReply](../app/ExampleClockReply.hs) можно посмотреть на тот шаблон "рабочий", который получает сообщения от своего контроллера.

В примере [Bank](../app/ExampleBank.hs) было показано, как производить вызов другого компонента и получать от него результат.

### Запускаемое приложение

В подавляющем большинстве случаев для разработки нового компонента запуск реализованной логики компонента может производиться с помощью функции `runApp`, которая описана в [этом](../src/System/MQ/Component/Internal/App.hs) файле.

Первым аргументом данной функции идёт имя компонента.
Правила его именования, а также то, как это имя должно соотноситься с конфигурационным файлом, описано в [этом](https://github.com/ozzzzz/mq/blob/develop/doc/ConfigJson.md) документе.
